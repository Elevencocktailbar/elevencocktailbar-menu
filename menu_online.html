<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Menu - Eleven Cocktail Bar</title>
  <style>
    :root { --bg:#0f0f10; --card:#17181a; --line:#2a2c2f; --txt:#f4f5f7; --muted:#b9bcc3; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; background:var(--bg); color:var(--txt); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 18px; }
    header { display:flex; align-items:baseline; justify-content:space-between; gap:12px; margin-bottom: 14px; }
    h1 { font-size: 26px; margin: 0; letter-spacing: .2px; }
    .stamp { font-size: 12px; color: var(--muted); }

    details { background: var(--card); border: 1px solid var(--line); border-radius: 14px; overflow:hidden; margin: 10px 0; }
    summary { cursor:pointer; list-style:none; padding: 14px 14px; font-weight: 800; letter-spacing: .3px; }
    summary::-webkit-details-marker { display:none; }

    .items { padding: 6px 14px 12px 14px; }
    .item { display:flex; justify-content:space-between; gap:14px; padding: 10px 0; border-top: 1px solid #24262a; }
    .left { min-width: 0; }
    .name { font-weight: 800; }
    .recipe { color: var(--muted); margin-top: 4px; line-height: 1.35; }
    .price { white-space: nowrap; font-weight: 800; }

    /* Mobile */
    @media (max-width: 520px) {
      .item { flex-direction: column; }
      .price { align-self: flex-start; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Menu</h1>
      <div class="stamp" id="stamp"></div>
    </header>

    <div id="root"></div>
  </div>

  <script>
    const DATA_URL = 'menu_online.json';

    // ogni quanto controllare aggiornamenti quando la pagina è visibile
    const POLL_MS = 15000; // 30s (puoi mettere 15000 o 60000)

    const root = document.getElementById('root');
    const stamp = document.getElementById('stamp');

    let lastGeneratedAt = null;   // per evitare re-render se non cambia
    let pollTimer = null;

    function euro(v) {
      if (v === null || v === undefined || v === '') return '';
      const n = Number(v);
      if (Number.isNaN(n)) return String(v);
      return n.toFixed(n % 1 === 0 ? 0 : 2).replace('.', ',') + ' €';
    }

    function normalizeGeneratedAt(g) {
      if (!g) return null;
      // supporta sia "2026-01-20T18:13:16" sia "2026-01-20 18:13:16"
      return String(g).replace('T', ' ').trim();
    }

    function render(MENU) {
      const gen = normalizeGeneratedAt(MENU?.generated_at);
      stamp.textContent = gen ? ('Aggiornato: ' + gen) : '';

      if (!MENU?.categories || !MENU.categories.length) {
        root.innerHTML = '<p style="color:#b9bcc3">Nessun prodotto online.</p>';
        return;
      }

      root.innerHTML = '';

      for (const cat of MENU.categories) {
        const d = document.createElement('details');
        d.open = false;

        const s = document.createElement('summary');
        s.textContent = cat.name;
        d.appendChild(s);

        const items = document.createElement('div');
        items.className = 'items';

        for (const it of (cat.items || [])) {
          const row = document.createElement('div');
          row.className = 'item';

          const left = document.createElement('div');
          left.className = 'left';

          const name = document.createElement('div');
          name.className = 'name';
          name.textContent = it.name ?? '';
          left.appendChild(name);

          if (it.ingredients) {
            const r = document.createElement('div');
            r.className = 'recipe';
            r.textContent = it.ingredients;
            left.appendChild(r);
          }

          const price = document.createElement('div');
          price.className = 'price';
          price.textContent = euro(it.price);

          row.appendChild(left);
          row.appendChild(price);
          items.appendChild(row);
        }

        d.appendChild(items);
        root.appendChild(d);
      }
    }

    async function fetchMenu() {
      const bust = Date.now();
      const resp = await fetch(`${DATA_URL}?v=${bust}`, {
        cache: 'no-store',
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      return await resp.json();
    }

    async function loadAndRender(force = false) {
      try {
        const MENU = await fetchMenu();

        const gen = normalizeGeneratedAt(MENU?.generated_at);

        // Se non c'è generated_at, renderizza comunque (non possiamo confrontare)
        if (!force && gen && lastGeneratedAt === gen) {
          return; // nessuna modifica
        }

        // Render
        render(MENU);

        // Memorizza versione
        lastGeneratedAt = gen || lastGeneratedAt;

      } catch (e) {
        // Non cancelliamo quello che c'è già a schermo (così il cliente continua a vedere il menu)
        // Mostriamo solo un piccolo messaggio nello "stamp" se non c'è già un aggiornamento.
        if (!stamp.textContent) {
          stamp.textContent = 'Aggiornamento in corso...';
        }
      }
    }

    function startPolling() {
      if (pollTimer) return;
      pollTimer = setInterval(() => {
        if (document.visibilityState === 'visible') {
          loadAndRender(false);
        }
      }, POLL_MS);
    }

    function stopPolling() {
      if (!pollTimer) return;
      clearInterval(pollTimer);
      pollTimer = null;
    }

    // 1) primo caricamento
    loadAndRender(true);

    // 2) quando l’utente torna sulla pagina, aggiorna subito
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        loadAndRender(false);
        startPolling();
      } else {
        stopPolling();
      }
    });

    // 3) polling attivo fin da subito (se la pagina è visibile)
    if (document.visibilityState === 'visible') startPolling();

    // 4) quando torna online, aggiorna subito
    window.addEventListener('online', () => loadAndRender(false));
  </script>
</body>
</html>

